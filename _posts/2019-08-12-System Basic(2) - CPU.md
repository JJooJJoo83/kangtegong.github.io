---
layout: post
title: "시스템 기초(1) CPU-2"
image: ''
date: 2019-08-12 10:24:06
tags: 
- System
- Computer_Architecture
- Tutorials
description: 시스템 프로그래밍과 리버싱의 기본 소양 - CPU편
categories:
- System_Basic
---


## 시스템 프로그래밍의 기초(1) : CPU 편

### 제어문 (분기, 반복문)의 원리

모든 프로그램은 순차 진행, 조건 분기, 반복의 흐름대로 진행된다.

순차진행은 어드레스에 있는 명령어를 실행하는 것,
조건분기는 조건에 따라 임의의 어드레스에 있는 명령어를 실행하는 것,
반복은 같은 어드레스의 명령어를 일정 횟수만큼 반복실행하는 것으로도 볼 수 있다.

이를 Program Counter안에 들어있는 어드레스의 관점으로 본다면,
순차진행은 프로그램 카운터가 하나씩 증가하는 것, 
조건분기는 임의의 어드레스로 점프(직접 이동)하여 분기하는 것,
반복은 이전의 어드레스로 돌아가서 같은 명령어를 반복하는 것으로 해석이 가능하다.

### 플래그 레지스터

그렇다면 분기나 반복을 해야 할 상황은 어떻게 판단할까?
플래그 레지스터를 이용해 판단하게 된다.

플래그 레지스터는 바로 직전 수행한 연산의 결과값, 즉 ACC에 들어간 값이 양수, 0, 음수 중 어떤 것이 되었는가 (값의 부로)를 기록하는 역할을 한다. (그 밖에도 오버플로우, 패리티 체크 등의 역할도 수행한다)

(비교연산의 결과값이 음수인지 양수인지 0인지는 플래그 레지스터의 마지막 세 개의 비트로 판단)

![PC원리]({{ 'https://t1.daumcdn.net/cfile/tistory/1235C0424E3174ED18' | relative_url }}){: .center-image }


CPU가 어떤 연산을 할 때마다 이 플래그 레지스터가 자동으로 갱신되는데, 점프를 할지 하지 않을지는 이 플래그 레지스터의 값을 보고 판단하게된다.

### CPU가 비교를 수행하는 원리 : 뺄셈

CPU가 비교를 수행하는 본질적인 원리는 뺄셈이다.
X와 Y의 대소비교를 한다고 했을 때, CPU는 내부에서 X-Y 연산을 수행하고 그 결과값을 0과 비교하여 0보다 크면 X>Y, 0이면 X=Y, 0보다 작으면 X<Y 판단을 내린다.

물론 X-Y의 결과값 (음수, 양수, 0)은 플래그 레지스터에 담기게 된다.

## 함수 호출의 원리

함수 호출도 본질적으로는 분기(점프)라고 볼 수 있다.
함수가 보관된 어드레스의 값을 프로그램 카운터에 넣어주기만 하면 되기 때문이다. 
하지만 다른 제어문과 한 가지 차이가 있다면 리턴을 하는 과정이 포함되어있다는 것이다.

프로그램 내부에서 함수 처리가 끝나면, 함수를 호출한 명령어의 다음 주소로 돌아가 그 곳에서부터 다시 코드를 실행해야 하기 때문이다. 따라서 함수를 호출할 때는 
1. 함수가 어디에 있는지 (어느 주소로 점프해야 하는지) - call
2. 함수의 실행이 끝난 후 어디로 돌아가야 하는지 - return

이 두 가지 사실을 아는 방법이 필요하다.

이 때 스택을 이용하게 되는데, 함수 호출이 끝나고 돌아가야 할 어드레스의 값을 스택에 담고, 함수호출이 끝나면 스택에 있는 돌아갈 주소를 다시 Program Counter에 담음으로써 돌아가게 된다.

함수의 시작 어드레스를 프로그램 카운터에 넣는 과정과 함수 실행이 끝난 후 돌아갈 주소를 스택에 담는 과정은 호출 명령어에 의해 실행된다.

이 호출 명령어에 대한 자세한 내용은 다음에 다루기로.